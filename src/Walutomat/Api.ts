/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export enum AnyCurrency {
  AUD = "AUD",
  BGN = "BGN",
  CAD = "CAD",
  CHF = "CHF",
  CNY = "CNY",
  CZK = "CZK",
  DKK = "DKK",
  EUR = "EUR",
  GBP = "GBP",
  HKD = "HKD",
  ILS = "ILS",
  JPY = "JPY",
  MXN = "MXN",
  NOK = "NOK",
  NZD = "NZD",
  PLN = "PLN",
  RON = "RON",
  SEK = "SEK",
  SGD = "SGD",
  TRY = "TRY",
  USD = "USD",
  ZAR = "ZAR",
  HUF = "HUF",
}

export enum MarketPair {
  EURGBP = "EURGBP",
  EURUSD = "EURUSD",
  EURCHF = "EURCHF",
  EURPLN = "EURPLN",
  GBPUSD = "GBPUSD",
  GBPCHF = "GBPCHF",
  GBPPLN = "GBPPLN",
  USDCHF = "USDCHF",
  USDPLN = "USDPLN",
  CHFPLN = "CHFPLN",
  EURSEK = "EURSEK",
  EURNOK = "EURNOK",
  EURDKK = "EURDKK",
  EURCZK = "EURCZK",
  CZKPLN = "CZKPLN",
  DKKPLN = "DKKPLN",
  NOKPLN = "NOKPLN",
  SEKPLN = "SEKPLN",
  AUDPLN = "AUDPLN",
  BGNPLN = "BGNPLN",
  CADPLN = "CADPLN",
  CNYPLN = "CNYPLN",
  HKDPLN = "HKDPLN",
  HUFPLN = "HUFPLN",
  ILSPLN = "ILSPLN",
  JPYPLN = "JPYPLN",
  MXNPLN = "MXNPLN",
  NZDPLN = "NZDPLN",
  RONPLN = "RONPLN",
  SGDPLN = "SGDPLN",
  TRYPLN = "TRYPLN",
  ZARPLN = "ZARPLN",
  EURAUD = "EURAUD",
  EURBGN = "EURBGN",
  EURCAD = "EURCAD",
  EURCNY = "EURCNY",
  EURHKD = "EURHKD",
  EURHUF = "EURHUF",
  EURILS = "EURILS",
  EURJPY = "EURJPY",
  EURMXN = "EURMXN",
  EURNZD = "EURNZD",
  EURRON = "EURRON",
  EURSGD = "EURSGD",
  EURTRY = "EURTRY",
  EURZAR = "EURZAR",
}

export enum NonibanTransfersCurrency {
  EUR = "EUR",
  USD = "USD",
  AUD = "AUD",
  CAD = "CAD",
  HKD = "HKD",
  NZD = "NZD",
  SGD = "SGD",
  GBP = "GBP",
  CHF = "CHF",
  CNY = "CNY",
  JPY = "JPY",
  CZK = "CZK",
  DKK = "DKK",
  NOK = "NOK",
  SEK = "SEK",
  PLN = "PLN",
  TBD = "TBD",
}

export enum MarketCurrency {
  EUR = "EUR",
  GBP = "GBP",
  USD = "USD",
  CHF = "CHF",
  PLN = "PLN",
  CZK = "CZK",
  DKK = "DKK",
  NOK = "NOK",
  SEK = "SEK",
}

export interface GenericResponse {
  /** True when exchange request was valid and succesfully handled, if false investigate errors table for details */
  success: boolean;
  errors?: ErrorType[];
}

export interface ErrorType {
  /**
   * Error key
   * @example "INSUFFICIENT_FUNDS"
   */
  key: ErrorTypeKeyEnum;
  /**
   * Descriptive error message with possible references to errorData entries
   * @example "Requested payout exceeds current wallet balance {walletBalance}"
   */
  description: string;
  errorData: ErrorData[];
}

export interface ErrorData {
  /**
   * Error data entry key
   * @example "walletBalance"
   */
  key: string;
  /**
   * Error data entry value
   * @example "3.14 EUR"
   */
  value: string;
}

export interface DuplicatableResponse {
  /** True when submitId was used before, in such a case no new operation like exchange or payout is performed. It is safe to repeat request e.g. in cases when response from first attempt was not received or processed */
  duplicate: boolean;
}

export type NewOrderResponse = GenericResponse &
  DuplicatableResponse & {
    result?: {
      /**
       * Identifier of the exchange order (generated by server, this is not `submitId`) or empty string when `dryRun=true`.
       * @example "2607f83b-3a60-4097-912c-72e1cf7a0085"
       */
      orderId: string;
    };
  };

export type ExchangeResponse = GenericResponse &
  DuplicatableResponse & {
    result?: {
      /**
       * Identifier of the exchange (generated by server, this is not `submitId`) or empty string when `dryRun=true`.
       * @example "2607f83b-3a60-4097-912c-72e1cf7a0085"
       */
      exchangeId: string;
    };
  };

export type NewTransferResponse = GenericResponse &
  DuplicatableResponse & {
    /** Container for transfer result */
    result?: {
      /**
       * Identifier of the transfer (generated by server, this is not `submitId`) or empty string when `dryRun=true`.
       * @example "2b5121cb-2b38-4fd8-be34-0aac4cf96c8d"
       */
      transferId: string;
      /**
       * Fee/commission amount applicable to given transfer
       * @example "3.00"
       */
      feeAmount: string;
      /**
       * Fee/commission currency (ISO currency code)
       * @example "PLN"
       */
      feeCurrency: NewTransferResponseFeeCurrencyEnum;
      /**
       * Used transfer type
       * @example "SEPA"
       */
      transferType: NewTransferResponseTransferTypeEnum;
    };
  };

export type TransferResponse = GenericResponse & {
  result?: {
    /**
     * Identifier of the transfer (generated by Walutomat)
     * @example "2b5121cb-2b38-4fd8-be34-0aac4cf96c8d"
     */
    transferId: string;
    /**
     * Identifier of client request that involves given wallet balance change (`submitId` of client API request when transfer were ordered via the API channel)
     * @example "916f1f98-01f6-412a-85e7-2482f1f4c112"
     */
    submitId?: string;
    /**
     * Timestamp of generated response, as transfer status may change in time
     * @example "2018-03-27T09:58:06.945Z"
     */
    responseTs: string;
    /**
     * Current transfer status:
     * * REQUEST_RECEIVED - Walutomat has received client payment order and assigned uniquie transfer ID to it
     * * SETTLED - transfer is setttled, i.e. either Walutomat has received SETTLED status directly from payment system or Walutomat has detected outgoing operation on his bank account related to the client payment order
     * * REJECTED - Walutomat was unable to succesfully place transfer in the payment system (or in the banks systems participating in given transaction) and funds were credited back to client Walutomat wallet
     * * RETURNED - Walutomat has received return transaction to given and credited it to client Walutomat wallet
     * @example "SETTLED"
     */
    transferStatus: TransferResponseTransferStatusEnum;
    /**
     * Timestamp indicating when Walutomat received transfer order from client (either via API or user panel)
     * @example "2018-03-27T09:58:06.945Z"
     */
    submittedTs?: string;
    /**
     * Timestamp indicating when SETTLED status was achieved (if already achieved)
     * @example "2018-03-27T09:58:06.945Z"
     */
    settledTs?: string;
    /**
     * Timestamp indicating when RETURNED status was achieved (if already achieved)
     * @example "2018-03-27T09:58:06.945Z"
     */
    returnedTs?: string;
    /** Transfer currency ISO currency code */
    currency?: TransferResponseCurrencyEnum;
    /**
     * Transfer amount
     * @example "99.00"
     */
    volume?: string;
    /** Transfer title */
    transferTitle?: string;
    /** The beneficiary (recipient) account, as entered in the transfer order */
    recipientAccount?: string;
    /** The beneficiary (recipient) name, as entered in the transfer order */
    recipientName?: string;
    /**
     * Information why transfer has been returned
     * @example "The account is closed"
     */
    returnReason?: string;
  };
};

export type OrderResponse = GenericResponse & {
  result?: OrderDetails;
};

export type OrdersResponse = GenericResponse & {
  result?: OrderDetails[];
};

export interface OrderDetails {
  /**
   * Unique order identifier assigned by market operator's system
   * @example "2035e361-e672-457a-9c3c-0e86e5ff54d6"
   */
  orderId: string;
  /**
   * Unique order identifier assigned by client system submitting new order. GUID or UUID highly advised
   * @example "916f1f98-01f6-412a-85e7-2482f1f4c112"
   */
  submitId: string;
  /**
   * Timestamp of order, as registered during order request acceptance
   * @example "2018-02-02T10:06:01.111Z"
   */
  submitTs: string;
  /**
   * Timestamp of last order update, such as status change or ecution progress update
   * @example "2018-02-02T10:06:01.396Z"
   */
  updateTs: string;
  /**
   * Order status, ACTIVE when still active on market
   * @example "ACTIVE"
   */
  status: OrderDetailsStatusEnum;
  /**
   * Percentage of executed order amount to total order volume, 100 when fullye executed
   * @example 67
   */
  completion: number;
  /**
   * Currency pair - base currency and counter currency
   * @example "EURPLN"
   */
  currencyPair: string;
  /** BUY or SELL order */
  buySell: OrderDetailsBuySellEnum;
  /**
   * Order volume, order limit (maximum amount of currency to be bought/sold depending on buySell attribute)
   * @example "999.00"
   */
  volume: string;
  volumeCurrency: MarketCurrency;
  /**
   * Maximum rate to buy currency at in case of BUY order, minimum rate to sell currency at in case of SELL order
   * @example "4.2321"
   */
  limitPrice?: string;
  /**
   * Amount of currency sold so far within this order
   * @example "999.00"
   */
  soldAmount?: string;
  soldCurrency?: MarketCurrency;
  /**
   * Amount of currency bought so far within this order. Commission is not deducted, amount deposited to customer wallet is boughtAmount - commissionAmount
   * @example "999.00"
   */
  boughtAmount?: string;
  boughtCurrency?: MarketCurrency;
  /**
   * Commission for fx order execution charged by platform operator so far
   * @example "9.00"
   */
  commissionAmount?: string;
  commissionCurrency?: MarketCurrency;
  /**
   * Commission rate applicable to this order
   * @example "0.0020"
   */
  commissionRate?: string;
}

export type FxRateResponse = GenericResponse & {
  result?: {
    /**
     * This is an identifier of the rate, you will reference the rate by this value, this is also timestamp of the currency quote
     * @example "2018-03-27T09:58:06.945Z"
     */
    ts: string;
    /**
     * Currency pair, i.e. base currency and counter currency
     * @example "EURPLN"
     */
    currencyPair: string;
    /**
     * This is a rate you can buy currency at, so at this rate Currency One sells
     * @example "4.1234"
     */
    buyRate: string;
    /**
     * This is a rate you can sell  scurrency at, so at this rate Currency One buys
     * @example "4.0987"
     */
    sellRate: string;
  };
};

export type BestOffersResponse = GenericResponse & {
  result?: {
    /**
     * timestamp of the snapshot
     * @example "2018-04-29T09:48:37.122Z"
     */
    ts: string;
    /**
     * Currency pair, i.e. base currency and counter currency
     * @example "EURPLN"
     */
    currencyPair: string;
    /** List of 10 best bid offers (e.g. in EURPLN offers of buying EUR paid in PLN). List could be shorter than 10 in rare situation of fewer than 10 bids in given currency pair on Walutomat stock exchange */
    bids: BidAsk[];
    /** List of 10 best ask offers (e.g. in EURPLN offers of selling EUR paid in PLN). List could be shorter than 10 in rare situation of fewer than 10 asks in given currency pair on Walutomat stock exchange */
    asks: BidAsk[];
  };
};

export interface BidAsk {
  /**
   * Price of the offer(s), 4 decimal places precision, e.g. if pair is EURPLN price 4.3518 means that 1 EUR is offered for 4.3518 PLN
   * @example 4.3518
   */
  price: string;
  /**
   * Volume, quantity of offered currency, e.g. if pair is EURPLN this value represents quantity of EUR offered
   * @example 962.65
   */
  volume: string;
  /**
   * Offer(s) amount, that is price * volume, e.g. if it is EURPLN this value represents offer value in PLN
   * @example 4189.27
   */
  valueInOppositeCurrency: string;
}

export type BestOffersDetailedResponse = GenericResponse & {
  result?: {
    /**
     * timestamp of the snapshot
     * @example "2018-04-29T09:48:37.122Z"
     */
    ts: string;
    /**
     * Currency pair, i.e. base currency and counter currency
     * @example "EURPLN"
     */
    currencyPair: string;
    /** List of 10 (or itemLimit) best bid offers (e.g. in EURPLN offers of buying EUR paid in PLN). List could be shorter than 10 (or itemLimit) in rare situation of Walutomat stock exchange having fewer bids in given currency pair */
    bids: BidAskDetailed[];
    /** List of 10 (or itemLimit) best ask offers (e.g. in EURPLN offers of selling EUR paid in PLN). List could be shorter than 10 (or itemLimit) in rare situation of Walutomat stock exchange having fewer asks in given currency pair */
    asks: BidAskDetailed[];
  };
};

export type BidAskDetailed = BidAsk & {
  /**
   * Either true or not defined. True when one or more offers of this price on this currency pair has been placed by the owner of the API key used to sign the request, otherwise not defined.
   * @example true
   */
  includesOwn?: boolean;
  /** List of individual offers of this price on this currency pair. */
  quotes: Quote[];
};

export interface Quote {
  /**
   * Time of the offer's placement.
   * @example "2025-05-30T19:53:18.856Z"
   */
  ts: string;
  /**
   * Volume, quantity of offered currency, e.g. if pair is EURPLN this value represents quantity of EUR offered
   * @example 962.65
   */
  volume: string;
  /**
   * Offer's amount, that is price * volume, e.g. if it is EURPLN this value represents offer value in PLN
   * @example 4189.27
   */
  valueInOppositeCurrency: string;
  /**
   * Either true or not defined. Indicates whether the offer has been placed by the owner of the API key used to sign the request. Otherwise not defined.
   * @example true
   */
  own?: boolean;
  /**
   * Unique order identifier assigned by market operator's system. Exists only if the offer has been placed by the owner of the API key used to sign the request. Otherwise not defined.
   * @example "2607f83b-3a60-4097-912c-72e1cf7a0085"
   */
  orderId?: string;
}

export type BalanceResponse = GenericResponse & {
  result?: BalanceItem[];
};

export interface BalanceItem {
  /** ISO currency code. Consult business documentation and agreement to determine which currencies are provided to you. */
  currency: BalanceItemCurrencyEnum;
  /**
   * Account balance (sum of available and blocked sources)
   * @example "123.00"
   */
  balanceTotal: string;
  /**
   * Balance of available sources on wallet
   * @example "99.00"
   */
  balanceAvailable: string;
  /**
   * Balance of blocked sources on wallet. Common reason are sources blocked to secure order execution on currency stock exchange or sources blocked for ordered and not yet executed money transfer.
   * @example "24.00"
   */
  balanceReserved: string;
}

export type HistoryMt940Response = GenericResponse & {
  result?: string;
};

export type HistoryResponse = GenericResponse & {
  result?: HistoryItem[];
};

export interface HistoryItem {
  /**
   * ID of the history item
   * @example 10003
   */
  historyItemId: number;
  /** Type of operation. Walutomat API distiguishes high level type of operations: payins, payouts from wallet, currency exchanges made in one of two models, commissions and fees, other operations not fitted to any of group mentioned earlier. */
  operationType: HistoryItemOperationTypeEnum;
  /** More specific operation type. */
  operationDetailedType: HistoryItemOperationDetailedTypeEnum;
  /**
   * Timestamp of operation
   * @example "2018-03-27T09:58:06.945Z"
   */
  ts: string;
  /** ISO currency code. Consult business documentation and agreement to determine which currencies are provided to you. */
  currency: HistoryItemCurrencyEnum;
  /**
   * Amount of currency credited or debited to wallet account in given currency. In case of debit operations, negaive sign is used.
   * @example "-999.00"
   */
  operationAmount: string;
  /**
   * Account balance after this operation. Note that in same cases wallet accounts may have negative balance (debit)
   * @example "123.00"
   */
  balanceAfter: string;
  /**
   * Identifier of Walutomat API transaction that results in account balance change. Please note that one transaction may affect multiple wallets more than one time, so this identifier may be identical in more than one wallet history item. E.g. exchange transaction affect at least 2 wallets (buyer and seller) in 2 currencies (bought and sold)
   * @example "2035e361-e672-457a-9c3c-0e86e5ff54d6"
   */
  transactionId?: string;
  /**
   * Identifier of client request that involves given wallet balance change, assigned by client system submitting new request. Not present when given wallet balance change is not result of client request submitted by Walutomat API.
   * @example "916f1f98-01f6-412a-85e7-2482f1f4c112"
   */
  submitId?: string;
  /**
   * Flag indicating that this entry is a correcting entry. Operations can be corrected by correcting entries that usually have opposite amounts.
   * @example false
   */
  correctingEntry?: boolean;
  operationDetails: {
    /**
     * operation detail entry key
     * @example "transferTitle"
     */
    key?: string;
    /**
     * operation detail entry value
     * @example "Invoice 1/01/2018, from John Smith"
     */
    value?: string;
  }[];
  /**
   * Combination of order channel and first five characters of used of the API key in case of API channel or panel user email address in case of GUI channel, for example: API/1a2b3... or BIZ/user@example.com
   * @example "/^(API|WT|BIZ)/(.*)?$/"
   */
  orderedBy?: string;
}

/**
 * Error key
 * @example "INSUFFICIENT_FUNDS"
 */
export enum ErrorTypeKeyEnum {
  AMOUNT_TOO_SMALL = "AMOUNT_TOO_SMALL",
  API_DISABLED = "API_DISABLED",
  COUNTRY_NOT_SUPPORTED = "COUNTRY_NOT_SUPPORTED",
  CURRENCY_NOT_SUPPORTED = "CURRENCY_NOT_SUPPORTED",
  INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS",
  INVALID_ACCOUNT_NUMBER = "INVALID_ACCOUNT_NUMBER",
  INVALID_API_KEY = "INVALID_API_KEY",
  INVALID_ARGUMENTS = "INVALID_ARGUMENTS",
  INVALID_SIGNATURE = "INVALID_SIGNATURE",
  MISSING_API_KEY = "MISSING_API_KEY",
  MISSING_AUTH_ROLE = "MISSING_AUTH_ROLE",
  MISSING_PUBLIC_KEY = "MISSING_PUBLIC_KEY",
  MISSING_SIGNATURE = "MISSING_SIGNATURE",
  NOT_AUTHORIZED = "NOT_AUTHORIZED",
  NO_RATE_FOR_PAIR = "NO_RATE_FOR_PAIR",
  OTHER = "OTHER",
  PAYOUT_LIMIT_EXCEEDED = "PAYOUT_LIMIT_EXCEEDED",
  TRANSACTION_NOT_FOUND = "TRANSACTION_NOT_FOUND",
  SOURCE_OF_INCOME_REQUIRED = "SOURCE_OF_INCOME_REQUIRED",
  PURPOSE_REQUIRED = "PURPOSE_REQUIRED",
  TITLE_REQUIRED = "TITLE_REQUIRED",
  AMOUNT_MUST_BE_INTEGER = "AMOUNT_MUST_BE_INTEGER",
}

/**
 * Fee/commission currency (ISO currency code)
 * @example "PLN"
 */
export enum NewTransferResponseFeeCurrencyEnum {
  EUR = "EUR",
  PLN = "PLN",
}

/**
 * Used transfer type
 * @example "SEPA"
 */
export enum NewTransferResponseTransferTypeEnum {
  SEPA = "SEPA",
  SEPAINSTANT = "SEPA INSTANT",
  SWIFTSHATODAY = "SWIFT SHA TODAY",
  SWIFTSHASPOT = "SWIFT SHA SPOT",
  SWIFTOURTODAY = "SWIFT OUR TODAY",
  DOMESTIC = "DOMESTIC",
  DOMESTICEXPRESS = "DOMESTIC EXPRESS",
  LOCAL = "LOCAL",
  INTERNAL = "INTERNAL",
}

/**
 * Current transfer status:
 * * REQUEST_RECEIVED - Walutomat has received client payment order and assigned uniquie transfer ID to it
 * * SETTLED - transfer is setttled, i.e. either Walutomat has received SETTLED status directly from payment system or Walutomat has detected outgoing operation on his bank account related to the client payment order
 * * REJECTED - Walutomat was unable to succesfully place transfer in the payment system (or in the banks systems participating in given transaction) and funds were credited back to client Walutomat wallet
 * * RETURNED - Walutomat has received return transaction to given and credited it to client Walutomat wallet
 * @example "SETTLED"
 */
export enum TransferResponseTransferStatusEnum {
  REQUEST_RECEIVED = "REQUEST_RECEIVED",
  SETTLED = "SETTLED",
  REJECTED = "REJECTED",
  RETURNED = "RETURNED",
}

/** Transfer currency ISO currency code */
export enum TransferResponseCurrencyEnum {
  AUD = "AUD",
  BGN = "BGN",
  CAD = "CAD",
  CHF = "CHF",
  CNY = "CNY",
  CZK = "CZK",
  DKK = "DKK",
  EUR = "EUR",
  GBP = "GBP",
  HKD = "HKD",
  ILS = "ILS",
  JPY = "JPY",
  MXN = "MXN",
  NOK = "NOK",
  NZD = "NZD",
  PLN = "PLN",
  RON = "RON",
  SEK = "SEK",
  SGD = "SGD",
  TRY = "TRY",
  USD = "USD",
  ZAR = "ZAR",
  HUF = "HUF",
}

/**
 * Order status, ACTIVE when still active on market
 * @example "ACTIVE"
 */
export enum OrderDetailsStatusEnum {
  ACTIVE = "ACTIVE",
  CLOSED = "CLOSED",
}

/** BUY or SELL order */
export enum OrderDetailsBuySellEnum {
  BUY = "BUY",
  SELL = "SELL",
}

/** ISO currency code. Consult business documentation and agreement to determine which currencies are provided to you. */
export enum BalanceItemCurrencyEnum {
  AUD = "AUD",
  BGN = "BGN",
  CAD = "CAD",
  CHF = "CHF",
  CNY = "CNY",
  CZK = "CZK",
  DKK = "DKK",
  EUR = "EUR",
  GBP = "GBP",
  HKD = "HKD",
  ILS = "ILS",
  JPY = "JPY",
  MXN = "MXN",
  NOK = "NOK",
  NZD = "NZD",
  PLN = "PLN",
  RON = "RON",
  SEK = "SEK",
  SGD = "SGD",
  TRY = "TRY",
  USD = "USD",
  ZAR = "ZAR",
  HUF = "HUF",
}

/** Type of operation. Walutomat API distiguishes high level type of operations: payins, payouts from wallet, currency exchanges made in one of two models, commissions and fees, other operations not fitted to any of group mentioned earlier. */
export enum HistoryItemOperationTypeEnum {
  PAYIN = "PAYIN",
  PAYOUT = "PAYOUT",
  COMMISSION = "COMMISSION",
  DIRECT_FX = "DIRECT_FX",
  MARKET_FX = "MARKET_FX",
  TRANSFER = "TRANSFER",
  OTHER = "OTHER",
}

/** More specific operation type. */
export enum HistoryItemOperationDetailedTypeEnum {
  PAYIN = "PAYIN",
  PAYIN_FEE = "PAYIN_FEE",
  PAYOUT = "PAYOUT",
  PAYOUT_FEE = "PAYOUT_FEE",
  PAYOUT_RETURN = "PAYOUT_RETURN",
  PAYOUT_FEE_RETURN = "PAYOUT_FEE_RETURN",
  PAYOUT_POST_FACTUM = "PAYOUT_POST_FACTUM",
  CASH_PAYOUT = "CASH_PAYOUT",
  CASH_PAYOUT_FEE = "CASH_PAYOUT_FEE",
  CASH_PAYOUT_RETURN = "CASH_PAYOUT_RETURN",
  PAYINP24 = "PAYIN_P24",
  PAYINP24FEE = "PAYIN_P24_FEE",
  PAYIN_PAYPAL = "PAYIN_PAYPAL",
  PAYIN_PAYPAL_FEE = "PAYIN_PAYPAL_FEE",
  MARKET_FX = "MARKET_FX",
  MARKET_FX_FEE = "MARKET_FX_FEE",
  DIRECT_FX = "DIRECT_FX",
  CHARGE_COMPENSATION = "CHARGE_COMPENSATION",
  CUSTOMER_PROFIT = "CUSTOMER_PROFIT",
  WT_PAY = "WT_PAY",
  INTERNAL = "INTERNAL",
  MONTHLY_FEE = "MONTHLY_FEE",
  OTHER = "OTHER",
}

/** ISO currency code. Consult business documentation and agreement to determine which currencies are provided to you. */
export enum HistoryItemCurrencyEnum {
  AUD = "AUD",
  BGN = "BGN",
  CAD = "CAD",
  CHF = "CHF",
  CNY = "CNY",
  CZK = "CZK",
  DKK = "DKK",
  EUR = "EUR",
  GBP = "GBP",
  HKD = "HKD",
  ILS = "ILS",
  JPY = "JPY",
  MXN = "MXN",
  NOK = "NOK",
  NZD = "NZD",
  PLN = "PLN",
  RON = "RON",
  SEK = "SEK",
  SGD = "SGD",
  TRY = "TRY",
  USD = "USD",
  ZAR = "ZAR",
  HUF = "HUF",
}

export enum GetHistoryParamsCurrenciesEnum {
  AUD = "AUD",
  BGN = "BGN",
  CAD = "CAD",
  CHF = "CHF",
  CNY = "CNY",
  CZK = "CZK",
  DKK = "DKK",
  EUR = "EUR",
  GBP = "GBP",
  HKD = "HKD",
  ILS = "ILS",
  JPY = "JPY",
  MXN = "MXN",
  NOK = "NOK",
  NZD = "NZD",
  PLN = "PLN",
  RON = "RON",
  SEK = "SEK",
  SGD = "SGD",
  TRY = "TRY",
  USD = "USD",
  ZAR = "ZAR",
  HUF = "HUF",
}

/** Can be used to limit results to selected operation type like payin, payout, currency exchange or commission, if not provided all operations of any kind on multicurrency wallet are returned */
export enum GetHistoryParamsOperationTypeEnum {
  PAYIN = "PAYIN",
  PAYOUT = "PAYOUT",
  COMMISSION = "COMMISSION",
  DIRECT_FX = "DIRECT_FX",
  MARKET_FX = "MARKET_FX",
  TRANSFER = "TRANSFER",
  OTHER = "OTHER",
}

/** Can be used to limit results to selected operation detailed type */
export enum GetHistoryParamsOperationDetailedTypeEnum {
  PAYIN = "PAYIN",
  PAYIN_CARD = "PAYIN_CARD",
  PAYIN_CARD_FEE = "PAYIN_CARD_FEE",
  PAYIN_FEE = "PAYIN_FEE",
  PAYIN_PAYPAL = "PAYIN_PAYPAL",
  PAYIN_PAYPAL_FEE = "PAYIN_PAYPAL_FEE",
  PAYOUT = "PAYOUT",
  PAYOUT_FEE = "PAYOUT_FEE",
  PAYOUT_RETURN = "PAYOUT_RETURN",
  PAYOUT_FEE_RETURN = "PAYOUT_FEE_RETURN",
  PAYOUT_POST_FACTUM = "PAYOUT_POST_FACTUM",
  CASH_PAYOUT = "CASH_PAYOUT",
  CASH_PAYOUT_FEE = "CASH_PAYOUT_FEE",
  CASH_PAYOUT_RETURN = "CASH_PAYOUT_RETURN",
  PAYINP24 = "PAYIN_P24",
  PAYINP24FEE = "PAYIN_P24_FEE",
  PAYINP24BLIK = "PAYIN_P24_BLIK",
  PAYIN_BLIK = "PAYIN_BLIK",
  PAYIN_BLIK_FEE = "PAYIN_BLIK_FEE",
  PAYINP24GPAY = "PAYIN_P24_GPAY",
  PAYINP24NOW = "PAYIN_P24_NOW",
  MARKET_FX = "MARKET_FX",
  MARKET_FX_FEE = "MARKET_FX_FEE",
  DIRECT_FX = "DIRECT_FX",
  CHARGE_COMPENSATION = "CHARGE_COMPENSATION",
  CUSTOMER_PROFIT = "CUSTOMER_PROFIT",
  WT_PAY = "WT_PAY",
  INTERNAL = "INTERNAL",
  MONTHLY_FEE = "MONTHLY_FEE",
  OTHER = "OTHER",
}

/**
 * Sort order of returned elements.
 * @default "DESC"
 */
export enum GetHistoryParamsSortOrderEnum {
  ASC = "ASC",
  DESC = "DESC",
}

export enum HistoryMt940ListParamsCurrenciesEnum {
  AUD = "AUD",
  BGN = "BGN",
  CAD = "CAD",
  CHF = "CHF",
  CNY = "CNY",
  CZK = "CZK",
  DKK = "DKK",
  EUR = "EUR",
  GBP = "GBP",
  HKD = "HKD",
  ILS = "ILS",
  JPY = "JPY",
  MXN = "MXN",
  NOK = "NOK",
  NZD = "NZD",
  PLN = "PLN",
  RON = "RON",
  SEK = "SEK",
  SGD = "SGD",
  TRY = "TRY",
  USD = "USD",
  ZAR = "ZAR",
  HUF = "HUF",
}

/** Currency pair, i.e. base currency and counter currency with no separator, e.g. EURPLN */
export enum GetBestOffersParamsCurrencyPairEnum {
  EURGBP = "EURGBP",
  EURUSD = "EURUSD",
  EURCHF = "EURCHF",
  EURPLN = "EURPLN",
  GBPUSD = "GBPUSD",
  GBPCHF = "GBPCHF",
  GBPPLN = "GBPPLN",
  USDCHF = "USDCHF",
  USDPLN = "USDPLN",
  CHFPLN = "CHFPLN",
  EURSEK = "EURSEK",
  EURNOK = "EURNOK",
  EURDKK = "EURDKK",
  EURCZK = "EURCZK",
  CZKPLN = "CZKPLN",
  DKKPLN = "DKKPLN",
  NOKPLN = "NOKPLN",
  SEKPLN = "SEKPLN",
  AUDPLN = "AUDPLN",
  BGNPLN = "BGNPLN",
  CADPLN = "CADPLN",
  CNYPLN = "CNYPLN",
  HKDPLN = "HKDPLN",
  HUFPLN = "HUFPLN",
  ILSPLN = "ILSPLN",
  JPYPLN = "JPYPLN",
  MXNPLN = "MXNPLN",
  NZDPLN = "NZDPLN",
  RONPLN = "RONPLN",
  SGDPLN = "SGDPLN",
  TRYPLN = "TRYPLN",
  ZARPLN = "ZARPLN",
  EURAUD = "EURAUD",
  EURBGN = "EURBGN",
  EURCAD = "EURCAD",
  EURCNY = "EURCNY",
  EURHKD = "EURHKD",
  EURHUF = "EURHUF",
  EURILS = "EURILS",
  EURJPY = "EURJPY",
  EURMXN = "EURMXN",
  EURNZD = "EURNZD",
  EURRON = "EURRON",
  EURSGD = "EURSGD",
  EURTRY = "EURTRY",
  EURZAR = "EURZAR",
}

/** Currency pair, i.e. base currency and counter currency with no separator, e.g. EURPLN */
export enum GetBestOffersDetailedParamsCurrencyPairEnum {
  EURGBP = "EURGBP",
  EURUSD = "EURUSD",
  EURCHF = "EURCHF",
  EURPLN = "EURPLN",
  GBPUSD = "GBPUSD",
  GBPCHF = "GBPCHF",
  GBPPLN = "GBPPLN",
  USDCHF = "USDCHF",
  USDPLN = "USDPLN",
  CHFPLN = "CHFPLN",
  EURSEK = "EURSEK",
  EURNOK = "EURNOK",
  EURDKK = "EURDKK",
  EURCZK = "EURCZK",
  CZKPLN = "CZKPLN",
  DKKPLN = "DKKPLN",
  NOKPLN = "NOKPLN",
  SEKPLN = "SEKPLN",
  AUDPLN = "AUDPLN",
  BGNPLN = "BGNPLN",
  CADPLN = "CADPLN",
  CNYPLN = "CNYPLN",
  HKDPLN = "HKDPLN",
  HUFPLN = "HUFPLN",
  ILSPLN = "ILSPLN",
  JPYPLN = "JPYPLN",
  MXNPLN = "MXNPLN",
  NZDPLN = "NZDPLN",
  RONPLN = "RONPLN",
  SGDPLN = "SGDPLN",
  TRYPLN = "TRYPLN",
  ZARPLN = "ZARPLN",
  EURAUD = "EURAUD",
  EURBGN = "EURBGN",
  EURCAD = "EURCAD",
  EURCNY = "EURCNY",
  EURHKD = "EURHKD",
  EURHUF = "EURHUF",
  EURILS = "EURILS",
  EURJPY = "EURJPY",
  EURMXN = "EURMXN",
  EURNZD = "EURNZD",
  EURRON = "EURRON",
  EURSGD = "EURSGD",
  EURTRY = "EURTRY",
  EURZAR = "EURZAR",
}

/** Currency pair, i.e. base currency and counter currency with no separator, e.g. EURPLN, must be a pair listed on Walutomat market */
export enum NewOrderCurrencyPairEnum {
  EURGBP = "EURGBP",
  EURUSD = "EURUSD",
  EURCHF = "EURCHF",
  EURPLN = "EURPLN",
  GBPUSD = "GBPUSD",
  GBPCHF = "GBPCHF",
  GBPPLN = "GBPPLN",
  USDCHF = "USDCHF",
  USDPLN = "USDPLN",
  CHFPLN = "CHFPLN",
  EURSEK = "EURSEK",
  EURNOK = "EURNOK",
  EURDKK = "EURDKK",
  EURCZK = "EURCZK",
  CZKPLN = "CZKPLN",
  DKKPLN = "DKKPLN",
  NOKPLN = "NOKPLN",
  SEKPLN = "SEKPLN",
  AUDPLN = "AUDPLN",
  BGNPLN = "BGNPLN",
  CADPLN = "CADPLN",
  CNYPLN = "CNYPLN",
  HKDPLN = "HKDPLN",
  HUFPLN = "HUFPLN",
  ILSPLN = "ILSPLN",
  JPYPLN = "JPYPLN",
  MXNPLN = "MXNPLN",
  NZDPLN = "NZDPLN",
  RONPLN = "RONPLN",
  SGDPLN = "SGDPLN",
  TRYPLN = "TRYPLN",
  ZARPLN = "ZARPLN",
  EURAUD = "EURAUD",
  EURBGN = "EURBGN",
  EURCAD = "EURCAD",
  EURCNY = "EURCNY",
  EURHKD = "EURHKD",
  EURHUF = "EURHUF",
  EURILS = "EURILS",
  EURJPY = "EURJPY",
  EURMXN = "EURMXN",
  EURNZD = "EURNZD",
  EURRON = "EURRON",
  EURSGD = "EURSGD",
  EURTRY = "EURTRY",
  EURZAR = "EURZAR",
}

/** BUY or SELL order type */
export enum NewOrderBuySellEnum {
  BUY = "BUY",
  SELL = "SELL",
}

/** Currency of provided volume value. ISO currency code. */
export enum NewOrderVolumeCurrencyEnum {
  EUR = "EUR",
  GBP = "GBP",
  USD = "USD",
  CHF = "CHF",
  PLN = "PLN",
  CZK = "CZK",
  DKK = "DKK",
  NOK = "NOK",
  SEK = "SEK",
}

/** BUY or SELL operation */
export enum NewExchangeBuySellEnum {
  BUY = "BUY",
  SELL = "SELL",
}

/** Currency of provided volume value. ISO currency code. */
export enum NewExchangeVolumeCurrencyEnum {
  AUD = "AUD",
  BGN = "BGN",
  CAD = "CAD",
  CHF = "CHF",
  CNY = "CNY",
  CZK = "CZK",
  DKK = "DKK",
  EUR = "EUR",
  GBP = "GBP",
  HKD = "HKD",
  ILS = "ILS",
  JPY = "JPY",
  MXN = "MXN",
  NOK = "NOK",
  NZD = "NZD",
  PLN = "PLN",
  RON = "RON",
  SEK = "SEK",
  SGD = "SGD",
  TRY = "TRY",
  USD = "USD",
  ZAR = "ZAR",
  HUF = "HUF",
}

/** ISO currency code. Consult business documentation and agreeement to determine in which currencies transfers are provided to you. */
export enum NewTransferInternalCurrencyEnum {
  AUD = "AUD",
  BGN = "BGN",
  CAD = "CAD",
  CHF = "CHF",
  CNY = "CNY",
  CZK = "CZK",
  DKK = "DKK",
  EUR = "EUR",
  GBP = "GBP",
  HKD = "HKD",
  ILS = "ILS",
  JPY = "JPY",
  MXN = "MXN",
  NOK = "NOK",
  NZD = "NZD",
  PLN = "PLN",
  RON = "RON",
  SEK = "SEK",
  SGD = "SGD",
  TRY = "TRY",
  USD = "USD",
  ZAR = "ZAR",
  HUF = "HUF",
}

/**
 * - `RECEIVER_VOLUME` means recipient will receive exact amount provided in volume attribute.
 * - `SENDER_VOLUME` means that volume attribute specifies sent volume (for certain transfers there are no guarantee that volume received is equal to volume sent, because extra charges may be deducted from transferred volume).
 *
 * Notes:
 *   - `transferCostInstruction` may have impact on transfer fee.
 *   - Business documentation specifies fees.
 */
export enum NewTransferInternalTransferCostInstructionEnum {
  SENDER_VOLUME = "SENDER_VOLUME",
  RECEIVER_VOLUME = "RECEIVER_VOLUME",
}

/** ISO currency code. Consult business documentation and agreeement to determine in which currencies transfers are provided to you. */
export enum NewTransferIbanCurrencyEnum {
  AUD = "AUD",
  BGN = "BGN",
  CAD = "CAD",
  CHF = "CHF",
  CNY = "CNY",
  CZK = "CZK",
  DKK = "DKK",
  EUR = "EUR",
  GBP = "GBP",
  HKD = "HKD",
  ILS = "ILS",
  JPY = "JPY",
  MXN = "MXN",
  NOK = "NOK",
  NZD = "NZD",
  PLN = "PLN",
  RON = "RON",
  SEK = "SEK",
  SGD = "SGD",
  TRY = "TRY",
  USD = "USD",
  ZAR = "ZAR",
  HUF = "HUF",
}

/**
 * - `RECEIVER_VOLUME` means recipient will receive exact amount provided in volume attribute.
 * - `SENDER_VOLUME` means that volume attribute specifies sent volume (for certain transfers there are no guarantee that volume received is equal to volume sent, because extra charges may be deducted from transferred volume).
 *
 * Notes:
 *   - `transferCostInstruction` may have impact on transfer fee.
 *   - It is possible that for certain countries and currencies we are not able to send transfer with RECEIVER_VOLUME option. In such case, requests with `RECEIVER_VOLUME` option will be rejected.
 *   - Business documentation specifies fees and possible transfer instructions for various transfer destinations.
 */
export enum NewTransferIbanTransferCostInstructionEnum {
  SENDER_VOLUME = "SENDER_VOLUME",
  RECEIVER_VOLUME = "RECEIVER_VOLUME",
}

/** The purpose of transfer. Might be required for high volume and offshore transfers, detailed usage conditions outlined in the business agreement. */
export enum NewTransferIbanTransferPurposeEnum {
  BILLS = "BILLS",
  COMMODITY = "COMMODITY",
  DONATION_ENTITY = "DONATION_ENTITY",
  DONATION_PERSON = "DONATION_PERSON",
  FAMILY = "FAMILY",
  PREPAYMENT = "PREPAYMENT",
  SERVICE = "SERVICE",
  PROPERTY = "PROPERTY",
  OTHER = "OTHER",
}

/** Source of funds. Might be required for high volume and offshore transfers, detailed usage conditions outlined in the business agreement. */
export enum NewTransferIbanSourceOfIncomeEnum {
  SALARY = "SALARY",
  SAVINGS = "SAVINGS",
  SCHOLARSHIP = "SCHOLARSHIP",
  INSURANCE = "INSURANCE",
  INVESTMENTS = "INVESTMENTS",
  DONATION = "DONATION",
  BUSINESS_INCOME = "BUSINESS_INCOME",
  OTHER = "OTHER",
}

/** The purpose of transfer. Might be required for high volume and offshore transfers, detailed usage conditions outlined in the business agreement. */
export enum NewTransferIbanSepaTransferPurposeEnum {
  BILLS = "BILLS",
  COMMODITY = "COMMODITY",
  DONATION_ENTITY = "DONATION_ENTITY",
  DONATION_PERSON = "DONATION_PERSON",
  FAMILY = "FAMILY",
  PREPAYMENT = "PREPAYMENT",
  SERVICE = "SERVICE",
  PROPERTY = "PROPERTY",
  OTHER = "OTHER",
}

/** Source of funds. Might be required for high volume and offshore transfers, detailed usage conditions outlined in the business agreement. */
export enum NewTransferIbanSepaSourceOfIncomeEnum {
  SALARY = "SALARY",
  SAVINGS = "SAVINGS",
  SCHOLARSHIP = "SCHOLARSHIP",
  INSURANCE = "INSURANCE",
  INVESTMENTS = "INVESTMENTS",
  DONATION = "DONATION",
  BUSINESS_INCOME = "BUSINESS_INCOME",
  OTHER = "OTHER",
}

/** ISO currency code. Consult business documentation and agreeement to determine in which currencies transfers are provided to you. */
export enum NewTransferNonibanCurrencyEnum {
  EUR = "EUR",
  USD = "USD",
  AUD = "AUD",
  CAD = "CAD",
  HKD = "HKD",
  NZD = "NZD",
  SGD = "SGD",
  GBP = "GBP",
  CHF = "CHF",
  CNY = "CNY",
  JPY = "JPY",
  CZK = "CZK",
  DKK = "DKK",
  NOK = "NOK",
  SEK = "SEK",
  PLN = "PLN",
  TBD = "TBD",
}

/** Two letter code of supported destination country. Note: check list of destination countries enabled on your account. */
export enum NewTransferNonibanCountryEnum {
  KR = "KR",
  CN = "CN",
  AU = "AU",
  CA = "CA",
  JP = "JP",
  NZ = "NZ",
  SG = "SG",
  TW = "TW",
  NG = "NG",
  GH = "GH",
  VN = "VN",
  IN = "IN",
  ET = "ET",
  ZA = "ZA",
  GM = "GM",
  GN = "GN",
  AR = "AR",
  BD = "BD",
  CL = "CL",
  ID = "ID",
  MX = "MX",
  MY = "MY",
  PY = "PY",
  QA = "QA",
  TH = "TH",
  UY = "UY",
  LK = "LK",
}

/**
 * - `RECEIVER_VOLUME` means recipient will receive exact amount provided in volume attribute.
 * - `SENDER_VOLUME` means that volume attribute specifies sent volume (for certain transfers there are no guarantee that volume received is equal to volume sent, because extra charges may be deducted from transferred volume).
 *
 * Notes:
 *   - `transferCostInstruction` may have impact on transfer fee.
 *   - It is possible that for certain countries and currencies we are not able to send transfer with RECEIVER_VOLUME option. In such case, requests with `RECEIVER_VOLUME` option will be rejected.
 *   - Business documentation specifies fees and possible transfer instructions for various transfer destinations.
 */
export enum NewTransferNonibanTransferCostInstructionEnum {
  SENDER_VOLUME = "SENDER_VOLUME",
  RECEIVER_VOLUME = "RECEIVER_VOLUME",
}

/** The purpose of transfer */
export enum NewTransferNonibanTransferPurposeEnum {
  BILLS = "BILLS",
  COMMODITY = "COMMODITY",
  DONATION_ENTITY = "DONATION_ENTITY",
  DONATION_PERSON = "DONATION_PERSON",
  FAMILY = "FAMILY",
  PREPAYMENT = "PREPAYMENT",
  SERVICE = "SERVICE",
  PROPERTY = "PROPERTY",
  OTHER = "OTHER",
}

/** Source of funds. */
export enum NewTransferNonibanSourceOfIncomeEnum {
  SALARY = "SALARY",
  SAVINGS = "SAVINGS",
  SCHOLARSHIP = "SCHOLARSHIP",
  INSURANCE = "INSURANCE",
  INVESTMENTS = "INVESTMENTS",
  DONATION = "DONATION",
  BUSINESS_INCOME = "BUSINESS_INCOME",
  OTHER = "OTHER",
}

export type QueryParamsType = Record<string | number, any>;
export type ResponseFormat = keyof Omit<Body, "body" | "bodyUsed">;

export interface FullRequestParams extends Omit<RequestInit, "body"> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean;
  /** request path */
  path: string;
  /** content type of request body */
  type?: ContentType;
  /** query params */
  query?: QueryParamsType;
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseFormat;
  /** request body */
  body?: unknown;
  /** base url */
  baseUrl?: string;
  /** request cancellation token */
  cancelToken?: CancelToken;
}

export type RequestParams = Omit<
  FullRequestParams,
  "body" | "method" | "query" | "path"
>;

export interface ApiConfig<SecurityDataType = unknown> {
  baseUrl?: string;
  baseApiParams?: Omit<RequestParams, "baseUrl" | "cancelToken" | "signal">;
  securityWorker?: (
    securityData: SecurityDataType | null,
  ) => Promise<RequestParams | void> | RequestParams | void;
  customFetch?: typeof fetch;
}

export interface HttpResponse<D extends unknown, E extends unknown = unknown>
  extends Response {
  data: D;
  error: E;
}

type CancelToken = Symbol | string | number;

export enum ContentType {
  Json = "application/json",
  FormData = "multipart/form-data",
  UrlEncoded = "application/x-www-form-urlencoded",
  Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
  public baseUrl: string = "/api/v2.0.0";
  private securityData: SecurityDataType | null = null;
  private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
  private abortControllers = new Map<CancelToken, AbortController>();
  private customFetch = (...fetchParams: Parameters<typeof fetch>) =>
    fetch(...fetchParams);

  private baseApiParams: RequestParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer",
  };

  constructor(apiConfig: ApiConfig<SecurityDataType> = {}) {
    Object.assign(this, apiConfig);
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data;
  };

  protected encodeQueryParam(key: string, value: any) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }

  protected addQueryParam(query: QueryParamsType, key: string) {
    return this.encodeQueryParam(key, query[key]);
  }

  protected addArrayQueryParam(query: QueryParamsType, key: string) {
    const value = query[key];
    return value.map((v: any) => this.encodeQueryParam(key, v)).join("&");
  }

  protected toQueryString(rawQuery?: QueryParamsType): string {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter(
      (key) => "undefined" !== typeof query[key],
    );
    return keys
      .map((key) =>
        Array.isArray(query[key])
          ? this.addArrayQueryParam(query, key)
          : this.addQueryParam(query, key),
      )
      .join("&");
  }

  protected addQueryParams(rawQuery?: QueryParamsType): string {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }

  private contentFormatters: Record<ContentType, (input: any) => any> = {
    [ContentType.Json]: (input: any) =>
      input !== null && (typeof input === "object" || typeof input === "string")
        ? JSON.stringify(input)
        : input,
    [ContentType.Text]: (input: any) =>
      input !== null && typeof input !== "string"
        ? JSON.stringify(input)
        : input,
    [ContentType.FormData]: (input: any) =>
      Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(
          key,
          property instanceof Blob
            ? property
            : typeof property === "object" && property !== null
              ? JSON.stringify(property)
              : `${property}`,
        );
        return formData;
      }, new FormData()),
    [ContentType.UrlEncoded]: (input: any) => this.toQueryString(input),
  };

  protected mergeRequestParams(
    params1: RequestParams,
    params2?: RequestParams,
  ): RequestParams {
    return {
      ...this.baseApiParams,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...(this.baseApiParams.headers || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {}),
      },
    };
  }

  protected createAbortSignal = (
    cancelToken: CancelToken,
  ): AbortSignal | undefined => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController = this.abortControllers.get(cancelToken);
      if (abortController) {
        return abortController.signal;
      }
      return void 0;
    }

    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };

  public abortRequest = (cancelToken: CancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);

    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };

  public request = async <T = any, E = any>({
    body,
    secure,
    path,
    type,
    query,
    format,
    baseUrl,
    cancelToken,
    ...params
  }: FullRequestParams): Promise<HttpResponse<T, E>> => {
    const secureParams =
      ((typeof secure === "boolean" ? secure : this.baseApiParams.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || ContentType.Json];
    const responseFormat = format || requestParams.format;

    return this.customFetch(
      `${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`,
      {
        ...requestParams,
        headers: {
          ...(requestParams.headers || {}),
          ...(type && type !== ContentType.FormData
            ? { "Content-Type": type }
            : {}),
        },
        signal:
          (cancelToken
            ? this.createAbortSignal(cancelToken)
            : requestParams.signal) || null,
        body:
          typeof body === "undefined" || body === null
            ? null
            : payloadFormatter(body),
      },
    ).then(async (response) => {
      const r = response.clone() as HttpResponse<T, E>;
      r.data = null as unknown as T;
      r.error = null as unknown as E;

      const data = !responseFormat
        ? r
        : await response[responseFormat]()
            .then((data) => {
              if (r.ok) {
                r.data = data;
              } else {
                r.error = data;
              }
              return r;
            })
            .catch((e) => {
              r.error = e;
              return r;
            });

      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }

      if (!response.ok) throw data;
      return data;
    });
  };
}

/**
 * @title Walutomat API
 * @version 2.0.0
 * @baseUrl /api/v2.0.0
 * @externalDocs http://walutomat.pl/en
 *
 * [Other versions](https://www.walutomat.pl/api/versions)
 * # Overview
 *
 * ## Introduction
 *
 * The Walutomat API is used to manage Walutomat multicurrency wallet from third party IT systems.
 * The API is built using RESTful endpoints and standard HTTP verbs.
 * JSON is returned on all our API responses, with a consistent structure for all messages.
 * Each response contains success flag and in case of failure, error section contains information necessary to investigate error reason.
 * Authentication to the API is performed via token-based auth (API key). Additionally sensitive operations like ordering money transfer must be signed with the private key. Further infromation on a topic of authentication and authorisation may be found in [dedicated section](#section/Usage/Authentication).
 * All API requests must be made over HTTPS. Calls made over plain HTTP will fail.
 * All requests must use TLS 1.1 or above.
 *
 * ## Getting started
 *
 * ### Samples
 *
 * Check for sample code demonstrating usage of Walutomat API in [this Github repository](https://github.com/Currency-One/api-examples)
 *
 * ### Sandbox
 *
 * We prepared sandbox to ease integration with Walutomat.
 * Developers may learn Walutomat API and test integration even before business arrangments are finalized.
 * Sandbox is best place to test changes first as well.
 * Sandbox URL: `walutomat.dev`
 * To request sandbox account, please contact us: api@walutomat.pl
 *
 * ### First steps
 *
 * Follow this simple step-by-step guide to get started using the Walutomat API.
 *
 * #### Generate your public/private key pair
 *
 * Generate a pair of RSA keys with key size of 4096 bits, here are examples for different operating systems:
 *
 * For Linux:
 * ```sh
 * $ openssl genrsa -out ./private.key 4096
 * $ openssl rsa -in ./private.key -pubout -out ./public.key
 * ```
 *
 * For Windows:
 * - Download and install PuTTY,
 * - Use PuTTYgen to generate RSA key, make sure you change "Number of bits in a generated key" to 4096,
 * - After key is generated in "Actions" section, click "Save public key", as it saves key in RSA PEM format,
 * - "Save private key" as well and store it somewhere.
 *
 * Generated key should look as follows:
 *
 * ```
 * -----BEGIN PUBLIC KEY-----
 * MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAucK1TudLBMAF0GjGII6h
 * 25k1kh0MBCNjNnVBWyOwc06ivr1Xg5U4EBXJqi4HQowhcOKHNVusL1KgsbRqwNvR
 * fGwXUgfp9CNeeKKZrgo98+0hUcR+wrR59F2dSnoQ4CWUHuUk5Tinj7mh2+uzu5BF
 * mJefy5d1Mj81ANbpwwETeo/OSK+3++h0ac+kfdokE57CjurnD3b5AMnQ6RLtZm2O
 * GnEtwWymxXLO84tdRYo/e/Rbg9/yTmDhpTDcexJDd1f5O6814BxL4TFe/6AnFa2y
 * nm+Ot9Sxa01OOEzHDQW6CK3x5BbH3rv6/5UAKoliWyTUcyDvIlikiO0eQPlHk/YP
 * W0dYGqFlSkdc8xDJByhiDZWZlnNUrKiLaJw/O6oybqme9+NnghiuQ8Ck3VO8ESpJ
 * Q90TV3Ffl+TkWoULKF/9iK37szwV57ogafgX0YimN+qkQjLPr/9s/PQxDLxd/JKq
 * WM4MTEkNxsE9Cw5r76Xkex3Z6X0YF89UryjFIuTi2+U5yow6gF6uBKcD2tYzMmdx
 * orCRtNSUrueH56+c7axDtIdoX0GGvCWIDT343I96Di2ZDKo8Lxx11vTNjLokJaDj
 * IQz12YrqNnKtAjqmDO+Y4mAU7qbFgiBGIT7R1JLoemiNhLf7UdX9g1/0AOyGvDxp
 * Pe62GHE5pTQ74mf5jxWseskCAwEAAQ==
 * -----END PUBLIC KEY-----
 * ```
 *
 * #### Upload your public RSA key and reveal your API key
 *
 * 1. Log into the Walutomat User Panel - [live production](https://user.walutomat.pl) or [sandbox environment](https://user.walutomat.dev) accordingly
 * 2. Go to section "Additional services" > "API Key" (contact our Customer Service if there is no API Key section in the Additional services menu)
 * 3. Using "Your API Keys v.2" section, add new key and paste the content of the `public.key` file
 * 4. Store the API key in a safe place. You will be able to view it later in the User Panel using additional authentication.
 * 5. Contact our Customer Service to setup your API Key permissions.
 *
 * ### Simple API usage scenario
 * Now, as you have Walutomat API activated, your API key generated and probably your public key uploaded in the user panel, you can try first calls to API endpoints.
 * We suggest you to try example provided below.
 * Please note you may use sandbox for first trials (recommended). If this is the case, please change production URL `api.walutomat.pl` to sandbox `api.walutomat.dev` in samples below.
 *
 *
 * #### Example, step 1: learn current exchange rate
 *
 * 1. Replace `API_KEY` and `path/to/private.key` in the command below
 * 2. Query the following endpoint to learn current exchange rate offered by Currency One
 * 3. You should see the exchange rate in the response; note down the `ts` attribute of the response, you will need it in the next step.
 *
 * ```sh
 * $ timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
 * $ endpoint="/api/v2.0.0/direct_fx/rates?currencyPair=EURPLN"
 * $ body=""
 * $ signature=$(echo -n "$timestamp$endpoint$body" | openssl dgst -sha256 -binary -sign /path/to/private.key | openssl enc -A -base64)
 * $ curl -i \
 *   -H "X-API-Key: API_KEY" \
 *   -H "X-API-Signature: $signature" \
 *   -H "X-API-Timestamp: $timestamp" \
 *   -X GET "https://api.walutomat.pl$endpoint"
 * ```
 *
 * > Example response:
 *
 * ```json
 *  {
 *     "success": true,
 *     "result": {
 *       "ts": "2018-03-27T09:58:06.945Z",
 *       "currencyPair": "EURPLN",
 *       "buyRate": "4.1234",
 *       "sellRate": "4.0987"
 *     }
 *  }
 * ```
 *
 * #### Example, step 2: order currency exchange
 *
 * Knowing current exchange rate you are now ready to order currency exchange accepting received exchange rate. Notice the `dryRun` flag. Set `dryRun=true` to test the action (no actual exchange would take place).
 *
 * 1. Use the command below replacing `API_KEY` and `/path/to/private.key`
 * 2. Replace `exchange_rate_ts` with the `ts` from the previous step.
 *
 * ```sh
 * $ timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
 * $ endpoint="/api/v2.0.0/direct_fx/exchanges"
 * $ body="dryRun=false&submitId=93a68f4d-ce40-40be-adac-3bb4d4b5e392&currencyPair=EURPLN&buySell=BUY&volume=999.00&volumeCurrency=EUR&ts=exchange_rate_ts"
 * $ signature=$(echo -n "$timestamp$endpoint$body" | openssl dgst -sha256 -binary -sign /path/to/private.key | openssl enc -A -base64)
 * $ curl -i \
 *   -d "$body" \
 *   -H "X-API-Key: API_KEY" \
 *   -H "X-API-Signature: $signature" \
 *   -H "X-API-Timestamp: $timestamp" \
 *   -H "Content-Type: application/x-www-form-urlencoded" \
 *   -X POST "https://api.walutomat.pl$endpoint"
 * ```
 *
 * > Example response:
 *
 * ```json
 *   {
 *     "success": true,
 *     "duplicate": false,
 *     "result": {
 *       "exchangeId": "2607f83b-3a60-4097-912c-72e1cf7a0085"
 *     }
 *   }
 *   ```
 *
 * **Note**: There are two models of currency exchange offered by Currency One via API: direct currency exchange with Currency One (endpoints in `direct_fx` namespace), used in this demonstration, and P2P exchange on Walutomat market (endpoints in `market_fx` namespace) - see further sections to learn more about those 2 models and acting on Walutomat market via API.
 *
 * Congratulations! You have performed your first currency exchange with Walutomat API.
 *
 * ### Next steps
 *
 * Now that you have performed your first currency exchange, you can learn more about the rest of the API.
 *
 * #### Learn about direct vs market exchange
 *
 * Currency One offers two types of currency exchange. Learn about the [difference](#section/Overview/Currency-exchange-models) and pick the right one for your system/business.
 *
 * #### Submit new currency exchange order to Walutomat market
 *
 * Now that you have performed your first direct currency exchange with Currency One, you can try the market model of currency exchange by submitting new [exchange order](#operation/newOrder) to Walutomat market. In this scenario Currency One is only platform operator and orders are executed if/when matching opposite order is available on the market.
 *
 * #### Order transfer from Walutomat multicurrency wallet
 *
 * After currency exchange you may want to transfer exchanged currency from Walutomat multicurrency wallet to your bank account or transfer it to third party. This operation can be requested via API as well and you use [transfer](#operation/newTransferIban) endpoint to achieve this.
 *
 * ## Currency exchange models
 *
 * The Walutomat API offers two different currency exchange types: direct and market.
 * A direct exchange is standard currency exchange with Currency One and requires to accept exchange rate offered by Currency One. The exchange rate is valid 10 minutes from its publication (publication timestamp is stored in `ts` attribute).
 * A market exchange uses Walutomat market, where all participants may submit their currency exchange offers (bids and asks). Walutomat API provides endpoints to act on this market, by learning current best offers available on the market, submitting new exchange order with limit price to Walutomat market, checking order execution (whether and how much of the offered currency were exchanged so far), withdrawing own offers from the market.
 * To distinguish API endpoints related to different  currency exchange models, endpoints dedicated to direct exchange with Currency one are located in `direct_fx/` namespace while endpoints dedicated to P2P currency exchange on Walutomat market are located in `market_fx/` namespace.
 *
 * ### Which type of exchange do I need?
 *
 * It depends upon your business model ad your system requirements. Note that in direct exchange model, exchange rate is known a priori and could be freezed up to ten minutes while in market exchange situation on the market changes dynamically. On the other hand, API to Walutomat market allows to design and automate different trading strategies that may perform well and significantly outrank results that would be achieved in direct exchange scenario.
 *
 * ## Backwards compatibility
 *
 * The following changes are considered backwards compatible:
 * * Adding new API endpoints
 * * Adding new properties to the responses from existing API endpoints
 * * Adding optional request parameters to existing API endpoints
 * * Altering the format or length of IDs
 * * Altering the message attributes returned by validation failures or other errors
 * * Reordering properties returned from existing API endpoints
 *
 * ## Changelog
 *
 * Release date | Description
 * ------------ | -----------
 * 2022-10-25 | Added endpoint GET /account/history/mt940 for mt940 export statement
 * 2022-03-21 | Added transferPurpose and sourceOfIncome optional params to /transfer/(non)iban endpoints
 * 2021-12-13 | Added operationDetailedType parameter to /account/history endpoint
 * 2021-08-24 | Added endpoint GET /transfer to learn transfer status and details
 * 2018-XX-XX | Added endpoints to history of operations on multicurrency wallet (payins, payouts, currency exchanges)
 * 2018-XX-XX | Release API version 2.0.0
 *
 * Documentation for earlier versions - see [v1](https://api.walutomat.pl/v1/)
 *
 * # Usage
 *
 * ## Authentication
 *
 * All API requests must be made over HTTPS. Any requests made over HTTP will fail.
 * The API uses token-based authentication. You will be provided with a API key which must be included in the header under X-API-Key attributes of all requests made to the API that requires authentication.
 * Additionally sensitive requests must be signed with RSA key with key size of 4096 bits and in such cases request signature shall be included in the request header in X-API-Signature attribute. Check specific endpoints documentation to learn given endpoint requirements.
 *
 * <!-- ReDoc-Inject: <security-definitions> -->
 *
 * ## Errors
 *
 * Responses contain `success` flag and `error` object.
 * If `success` attribute contains `false`, `error` object is not empty and shall be examined to learn error reason and details.
 *
 * ### Error object
 *
 * > Error object example:
 *
 * ```json
 *  {
 *     "success": false,
 *     "errors": [
 *       {
 *         "key": "INSUFFICIENT_FUNDS",
 *         "description": "Requested payout exceeds current wallet balance {walletBalance}",
 *         "trace": "",
 *         "errorData": [
 *           {
 *             "key": "walletBalance",
 *             "value": "3.14 EUR"
 *           }
 *         ]
 *       }
 *     ]
 *  }
 *
 * ```
 *
 * Error object always contains error `key` and error `description` in English. May contain key-value structure `errorData` with additional values that may be referred to in `description`. Error object may contain `trace` information. When unspecified error occurred, the trace can help to track the problem. You may be asked to deliver received response with trace content to our support team.
 *
 *
 * **Note**: It is assumed that all API endpoints always responds with 200 code and valid json success attribute. No response received or response with other code shall not be treated as confirmation of request rejection. In such cases recommended approach is to repeat request *with unchanged submitId*. See also Duplicates section.
 *
 * ![API response handling diagram](handling_responses.png)
 *
 *
 * ## Pagination
 *
 * Requests that return multiple items, e.g. `GET /account/history`, will be paginated to 100 items by default. You can access further items using the `?continueFrom` parameter. You can change default page size with `?volume` parameter. Items could be sorted from the newest created (default) or in reverse order by setting `?sortOrder` parameter to `ASC`.
 *
 * ## Duplicates
 *
 * You can safely repeat submitting requests, especially when you are unsure whether previous attempt reaches Walutomat or you did not manage to process Walutomat API response.
 *
 * **Note**: When repeating request make sure to provide same request id (`submitId`)!
 *
 * When Walutomat API receives request with same `submitId` parameter value again, it will not perform requested operation one more time, but simply repeats last response, this time with `duplicate` attribute set to `true`.
 *
 * ## Testing
 *
 * ### Dry run mode
 *
 * All requests that may incur charges or otherwise may affect multicurrency wallet balance (like currency exchange, payout) are equipped with `dryRun` parameter. When set to `true` dry run mode is on. In this mode request is just validated but not executed.
 *
 * #### Why use a `dryRun` flag?
 *
 * The key difference, for dryRun requests:
 * * requests does not affect money, no operation on multicurrency wallet is performed, no charges are incurred
 * * still, requests correctness is validated, possibility to perform request operation is verified and additional information is returned (e.g. the cost tested operation may incur)
 *
 * The main reasons for using dry run are therefore to:
 * * Verify your system have network connectivity with the Walutomat API
 * * Verify you are posting all the required data in the right format to the Walutomat API
 * * Verify you are handling the Walutomat API responses correctly
 *
 * but also to:
 * * Verify whether requested operation can be performed (e.g. indicated currencies are supported or IBAN account number is valid)
 * * Learn the cost of the operation if it would be requested not in dry run mode (i.e. you can use it to determine payout cost)
 *
 * ### Testing with sandbox
 *
 * Following tools are available on sandbox environment only:
 *
 * #### Payins (incoming transfer) simulator
 *
 * First log in to your sandbox user panel, then type in URL: [https://api.walutomat.pl/v1/](https://api.walutomat.pl/v1/)
 * Select payin parameters - executed pamyent will affect account balance and history of operations - usable to test `/account/history` endpoint response.
 *
 * #### Payout (outgoing transfer) status simulator
 *
 * This is a method to test 'R' events (Rejects, Returns) and possible states in `/transfer` endpoint response.
 * When submitting sandbox transfer request with `transfer/iban/sepa` endpoint enter into transfer title following keywords to obtain selected transfer status:
 * * TESTREJECT
 * * TESTRETURN
 * * TESTSETTLE
 */
export class Api<
  SecurityDataType extends unknown,
> extends HttpClient<SecurityDataType> {
  account = {
    /**
     * No description
     *
     * @tags account
     * @name GetBalances
     * @summary Returns wallet balance
     * @request GET:/account/balances
     * @secure
     */
    getBalances: (params: RequestParams = {}) =>
      this.request<BalanceResponse, any>({
        path: `/account/balances`,
        method: "GET",
        secure: true,
        format: "json",
        ...params,
      }),

    /**
     * @description **OperationDetails**: The table below presents keys provided in OperationDeatils depending on OperationType of an entry in the account history |  OperationType   | OperationDetailedType           | OperationDetails                                                                                                                                    | |------------------|---------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------| | PAYIN            | PAYIN                           | transferTitle, senderName, sourceAccount, destinationAccount                                                                                        | | PAYIN            | PAYIN_P24                       | transferTitle, paymentProviderId                                                                                                                    | | PAYIN            | PAYIN_CARD                      | transferTitle, provider, providerOperationId, cardNumber                                                                                            | | PAYIN            | PAYIN_PAYPAL                    | transferTitle                                                                                                                                       | | PAYIN            | PAYIN_P24_BLIK                  | transferTitle, provider, providerOperationId, cardNumber                                                                                            | | PAYIN            | PAYIN_BLIK                      | transferTitle, provider, providerOperationId, cardNumber                                                                                            | | PAYIN            | PAYIN_P24_GPAY                  | transferTitle, provider, providerOperationId, cardNumber                                                                                            | | PAYIN            | PAYIN_P24_NOW                   | transferTitle, paymentProviderId                                                                                                                    | | PAYOUT           | PAYOUT                          | destinationAccount, sourceAccount, ownerName, ownerAdress, country, swift, transferTitle                                                                           | | PAYOUT           | PAYOUT_REJECT                   | destinationAccount, sourceAccount, ownerName, ownerAdress, country, swift, transferTitle                                                                           | | PAYOUT           | PAYOUT_RETURN                   | destinationAccount, sourceAccount, ownerName, ownerAdress, country, swift, transferTitle, returnReasonCode, returnReasonText                                       | | PAYOUT           | PAYOUT_POST_FACTUM              | destinationAccount, sourceAccount, ownerName, ownerAdress, country, swift, transferTitle,                                                                          | | PAYOUT           | CASH_PAYOUT                     | no details                                                                                                                                          | | PAYOUT           | CASH_PAYOUT_RETURN              | no details                                                                                                                                          | | PAYOUT           | THIRD_PARTY_PAYOUT              | destinationAccount, ownerName, ownerAdress, country, swift, transferTitle                                                                           | | PAYOUT           | THIRD_PARTY_PAYOUT_REJECT       | destinationAccount, ownerName, ownerAdress, country, swift, transferTitle                                                                           | | PAYOUT           | THIRD_PARTY_PAYOUT_RETURN       | destinationAccount, ownerName, ownerAdress, country, swift, transferTitle, returnReasonCode, returnReasonText                                       | | PAYOUT           | PAYMENT_AGENT_PAYOUT            | destinationAccount, ownerName, ownerAddress, country, swift, transferTitle, debtorId, debtorName, debtorAccount                                     | | PAYOUT           | PAYMENT_AGENT_PAYOUT_REJECT     | destinationAccount, ownerName, ownerAddress, country, swift, transferTitle, debtorId, debtorName, debtorAccount                                     | | PAYOUT           | PAYMENT_AGENT_PAYOUT_RETURN     | destinationAccount, ownerName, ownerAddress, country, swift, transferTitle, debtorId, debtorName, debtorAccount, returnReasonCode, returnReasonCode | | MARKET_FX        | MARKET_FX                       | orderId, currencyPair, buySell, orderVolume, priceLimit                                                                                             | | DIRECT_FX        | DIRECT_FX                       | amountSold, amountBought, rate, rateTs                                                                                                              | | TRANSFER         | INTERNAL                        | title, senderAccountId, receiverAccountId, receiverDetails                                                                                          | | TRANSFER         | WT_PAY                          | title, senderAccountId, receiverAccountId, receiverDetails, partnerOrderId                                                                          | | COMMISSION       | PAYIN_FEE                       | transferTitle, senderName, sourceAccount, destinationAccount                                                                                        | | COMMISSION       | PAYIN_P24_FEE                   | transferTitle, paymentProviderId                                                                                                                    | | COMMISSION       | PAYIN_CARD_FEE                  | transferTitle, provider, providerOperationId, cardNumber                                                                                            | | COMMISSION       | PAYIN_BLIK_FEE                  | transferTitle, provider, providerOperationId, cardNumber                                                                                         | | COMMISSION       | PAYIN_PAYPAL_FEE                | transferTitle                                                                                                                                       | | COMMISSION       | PAYOUT_FEE                      | destinationAccount, ownerName, ownerAdress, country, swift, transferTitle                                                                           | | COMMISSION       | PAYOUT_REJECT_FEE               | destinationAccount, ownerName, ownerAdress, country, swift, transferTitle                                                                           | | COMMISSION       | CASH_PAYOUT_FEE                 | no details                                                                                                                                          | | COMMISSION       | THIRD_PARTY_PAYOUT_FEE          | destinationAccount, ownerName, ownerAdress, country, swift, transferTitle                                                                           | | COMMISSION       | THIRD_PARTY_PAYOUT_REJECT_FEE   | destinationAccount, ownerName, ownerAdress, country, swift, transferTitle                                                                           | | COMMISSION       | PAYMENT_AGENT_PAYOUT_FEE        | destinationAccount, ownerName, ownerAddress, country, swift, transferTitle, debtorId, debtorName, debtorAccount                                     | | COMMISSION       | PAYMENT_AGENT_PAYOUT_REJECT_FEE | destinationAccount, ownerName, ownerAddress, country, swift, transferTitle, debtorId, debtorName, debtorAccount                                     | | COMMISSION       | MARKET_FX_FEE                   | orderId, currencyPair, buySell, orderVolume, priceLimit                                                                                             | | COMMISSION       | CHARGE_COMPENSATION             | title                                                                                                                                               | | COMMISSION       | MONTHLY_FEE                     | no details                                                                                                                                          | | OTHER            | CUSTOMER_PROFIT                 | title                                                                                                                                               |
     *
     * @tags account
     * @name GetHistory
     * @summary Returns wallet history - operations recorded on the wallet
     * @request GET:/account/history
     * @secure
     */
    getHistory: (
      query?: {
        /**
         * Date in format YYYY-MM-DDThh:mm:ssTZD, if provided just operations recorded in this date and newer are returned (inclusive)
         * @format date-time
         */
        dateFrom?: string;
        /**
         * Date in format YYYY-MM-DDThh:mm:ssTZD, if provided just operations older than this date are returned (exclusive)
         * @format date-time
         */
        dateTo?: string;
        /** Comma-separated list of currency codes in ISO format, if provided only operations in given currencies are returned, otherwise operations in all currencies are returned */
        currencies?: GetHistoryParamsCurrenciesEnum[];
        /** Can be used to limit results to selected operation type like payin, payout, currency exchange or commission, if not provided all operations of any kind on multicurrency wallet are returned */
        operationType?: GetHistoryParamsOperationTypeEnum;
        /** Can be used to limit results to selected operation detailed type */
        operationDetailedType?: GetHistoryParamsOperationDetailedTypeEnum;
        /**
         * Maximum number of account operations fetched in one response. If actual number of operations satisfying request criteria exceeds volume number, response is trimmed to this number and next request with appropriate continueFrom parameter shall be used to read next batch of operations.
         * @min 1
         * @max 200
         * @default 200
         */
        itemLimit?: number;
        /**
         * ID of the history item the query will resume from. Usually the last historyItemId received in a prevoius batch. Item with provided id will not be included in the response (exclusive).
         * @min 1
         */
        continueFrom?: number;
        /**
         * Sort order of returned elements.
         * @default "DESC"
         */
        sortOrder?: GetHistoryParamsSortOrderEnum;
      },
      params: RequestParams = {},
    ) =>
      this.request<HistoryResponse, any>({
        path: `/account/history`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.UrlEncoded,
        format: "json",
        ...params,
      }),

    /**
     * @description The MT940 is a standard SWIFT message for electronic banking statements. MT940 statements used to import balances and transactions to ERP systems. MT940 statements are delivered as text in the result field. Format bases on MT940 SWIFT specification.
     *
     * @tags account
     * @name HistoryMt940List
     * @summary Returns wallet history (operations recorded on the wallet) in MT940 format
     * @request GET:/account/history/mt940
     * @secure
     */
    historyMt940List: (
      query: {
        /**
         * Date in format YYYY-MM-DD, if provided only dateFrom, given date automatically will be used for dateTo and operations recorded in this date are returned (inclusive)
         * @format date
         * @example "2020-01-01"
         */
        dateFrom: string;
        /**
         * Date in format YYYY-MM-DD, if provided just operations older than this date are returned (exclusive)
         * @format date
         * @example "2020-03-01"
         */
        dateTo?: string;
        /** Comma-separated list of currency codes in ISO format, if provided only operations in given currencies are returned, otherwise operations in all currencies are returned */
        currencies?: HistoryMt940ListParamsCurrenciesEnum[];
      },
      params: RequestParams = {},
    ) =>
      this.request<HistoryMt940Response, any>({
        path: `/account/history/mt940`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.UrlEncoded,
        format: "json",
        ...params,
      }),
  };
  directFx = {
    /**
     * @description Returns current exchange rate (buy and sell) offered by Currency One for specified currency pair
     *
     * @tags direct_fx
     * @name GetFxRate
     * @summary Returns current exchange rate
     * @request GET:/direct_fx/rates
     * @secure
     */
    getFxRate: (
      query: {
        /** Currency pair, i.e. base currency and counter currency with no separator, e.g. EURPLN */
        currencyPair: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<FxRateResponse, any>({
        path: `/direct_fx/rates`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.UrlEncoded,
        format: "json",
        ...params,
      }),

    /**
     * @description Requests currency exchange at rate provided by Currency One
     *
     * @tags direct_fx
     * @name NewExchange
     * @summary Requests currency exchange
     * @request POST:/direct_fx/exchanges
     * @secure
     */
    newExchange: (
      data: {
        /**
         * When true, dry run mode is on. In this mode currency exchange is not executed, only request correctness and possiblity to execute given exchange is checked instead
         * @default false
         */
        dryRun?: boolean;
        /**
         * Any unique exchange identifier assigned by sender, required when not dry run mode, must not be used when dryRun=true, example "93a68f4d-ce40-40be-adac-3bb4d4b5e392"
         * @pattern /^[a-zA-Z0-9_-]{1,36}$/
         */
        submitId?: string;
        /** Currency pair, i.e. base currency and counter currency with no separator, e.g. EURPLN. */
        currencyPair: string;
        /** BUY or SELL operation */
        buySell: NewExchangeBuySellEnum;
        /**
         * Exchange volume, example "999.00"
         * @pattern /^[0-9]{1,12}([.][0-9]{2})?$/
         */
        volume: string;
        /** Currency of provided volume value. ISO currency code. */
        volumeCurrency: NewExchangeVolumeCurrencyEnum;
        /**
         * An identifier of the rate received from Exchange rates response (it is always in ISO 8601 format), example "2018-03-27T09:58:06.945Z"
         * @format date-time
         */
        ts: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<ExchangeResponse, any>({
        path: `/direct_fx/exchanges`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.FormData,
        format: "json",
        ...params,
      }),
  };
  marketFx = {
    /**
     * No description
     *
     * @tags market_fx
     * @name GetBestOffers
     * @summary Returns 10 best bids and asks on currency pair in question
     * @request GET:/market_fx/best_offers
     */
    getBestOffers: (
      query: {
        /** Currency pair, i.e. base currency and counter currency with no separator, e.g. EURPLN */
        currencyPair: GetBestOffersParamsCurrencyPairEnum;
      },
      params: RequestParams = {},
    ) =>
      this.request<BestOffersResponse, any>({
        path: `/market_fx/best_offers`,
        method: "GET",
        query: query,
        type: ContentType.UrlEncoded,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags market_fx
     * @name GetBestOffersDetailed
     * @summary Returns more detailed list of best bids and asks on currency pair in question
     * @request GET:/market_fx/best_offers/detailed
     * @secure
     */
    getBestOffersDetailed: (
      query: {
        /** Currency pair, i.e. base currency and counter currency with no separator, e.g. EURPLN */
        currencyPair: GetBestOffersDetailedParamsCurrencyPairEnum;
        /**
         * Indicates how many uniquely priced offers are to be fetched (starting from the best).
         * @min 1
         * @default 10
         */
        itemLimit?: number;
      },
      params: RequestParams = {},
    ) =>
      this.request<BestOffersDetailedResponse, any>({
        path: `/market_fx/best_offers/detailed`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.UrlEncoded,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags market_fx
     * @name FindActiveOrders
     * @summary Returns active orders, ordered by most recently submitted.
     * @request GET:/market_fx/orders/active
     * @secure
     */
    findActiveOrders: (
      query?: {
        /**
         * Maximum items fetched in one response. Use olderThan parameter to get older orders.
         * @min 1
         * @max 100
         * @default 10
         */
        itemLimit?: number;
        /**
         * `submitTs` of the last order from previous response. Use this to fetch next batch of active orders, if any.
         * @format date-time
         */
        olderThan?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<OrdersResponse, any>({
        path: `/market_fx/orders/active`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.UrlEncoded,
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags market_fx
     * @name FindOrders
     * @summary Returns the list with an order specified by orderId or empty list if not found.
     * @request GET:/market_fx/orders
     * @secure
     */
    findOrders: (
      query: {
        /**
         * Order identifier returned during order creation, example "22dba34d-d266-4084-9f3e-1b2c7c78c172"
         * @minLength 36
         * @maxLength 36
         */
        orderId: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<OrdersResponse, any>({
        path: `/market_fx/orders`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.UrlEncoded,
        format: "json",
        ...params,
      }),

    /**
     * @description Platform allows to submit buy or sell order with price limit. Orders shall concern one of currency pairs listed on Walutomat market.
     *
     * @tags market_fx
     * @name NewOrder
     * @summary Submits new FX order to market
     * @request POST:/market_fx/orders
     * @secure
     */
    newOrder: (
      data: {
        /**
         * If set to true, dry run mode is on. In this mode order is not placed on market, only request correctness and possiblity to place order is checked
         * @default false
         */
        dryRun?: boolean;
        /**
         * Unique exchange identifier assigned by sender (GUID or UUID), required when not dry run mode, must not be used when dryRun=true, example "93a68f4d-ce40-40be-adac-3bb4d4b5e392"
         * @pattern /^[a-zA-Z0-9_-]{1,36}$/
         */
        submitId?: string;
        /** Currency pair, i.e. base currency and counter currency with no separator, e.g. EURPLN, must be a pair listed on Walutomat market */
        currencyPair: NewOrderCurrencyPairEnum;
        /** BUY or SELL order type */
        buySell: NewOrderBuySellEnum;
        /**
         * Order volume, order limit (maximum amount of currency to be bought/sold depending on buySell attribute)
         * @pattern /^[0-9]{1,12}([.][0-9]{2})?$/
         */
        volume: string;
        /** Currency of provided volume value. ISO currency code. */
        volumeCurrency: NewOrderVolumeCurrencyEnum;
        /**
         * Maximum rate to buy currency at in case of BUY order, minimum rate to sell currency at in case of SELL order
         * @pattern /^[0-9]{1,2}([.][0-9]{1,4})?$/
         */
        limitPrice: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<NewOrderResponse, any>({
        path: `/market_fx/orders`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.FormData,
        format: "json",
        ...params,
      }),

    /**
     * @description If given order is still active on market, it will be eventually withdrawn even though it is not fully executed. Please note that order might be partially executed before close request has arrived.
     *
     * @tags market_fx
     * @name CancelOrder
     * @summary Withdraw order from market
     * @request POST:/market_fx/orders/close
     * @secure
     */
    cancelOrder: (
      data: {
        /**
         * Order identifier returned during order creation, example "22dba34d-d266-4084-9f3e-1b2c7c78c172"
         * @minLength 36
         * @maxLength 36
         */
        orderId: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<OrderResponse, any>({
        path: `/market_fx/orders/close`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.FormData,
        format: "json",
        ...params,
      }),
  };
  transfer = {
    /**
     * @description Returns the transfer specified by transferId (transactionId) or ErrorType TRANSACTION_NOT_FOUND if not found.
     *
     * @tags payout
     * @name GetTransfer
     * @summary Learn transfer status and details
     * @request GET:/transfer
     * @secure
     */
    getTransfer: (
      query?: {
        /**
         * Transfer identifier assigned during transfer creation, example "22dba34d-d266-4084-9f3e-1b2c7c78c172" (if transfer ordered via API, could be found in the response, also visible in operations history available in the user panel and API endpoint). If both transferId and submitId are provided then only transferId is used.
         * @minLength 36
         * @maxLength 36
         */
        transferId?: string;
        /**
         * Unique transfer identifier assigned by sender when requesting this transfer. If both transferId and submitId are provided then only transferId is used.
         * @pattern /^[a-zA-Z0-9_-]{1,36}$/
         */
        submitId?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<TransferResponse, any>({
        path: `/transfer`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.UrlEncoded,
        format: "json",
        ...params,
      }),

    /**
     * @description Requests new internal transfer from own wallet to another wallet operated by Currency One. Both beneficiary and debtor must have wallets in Currency One opened. Could be used in dryRun mode to learn just transfer possibility and cost instead of perforing actual money transfer.
     *
     * @tags payout
     * @name NewTransferInternal
     * @summary Requests new internal transfer from own wallet to another wallet operated by Currency One.
     * @request POST:/transfer/internal
     * @secure
     */
    newTransferInternal: (
      data: {
        /**
         * When true, dry run mode is on. In this mode payout is not sent to execution, only request correctness, cost and possiblity to execute given transfer is checked instead
         * @default false
         */
        dryRun?: boolean;
        /**
         * Any unique transfer identifier assigned by sender, required when not dry run mode, must not be used when dryRun=true, example "93a68f4d-ce40-40be-adac-3bb4d4b5e392"
         * @pattern /^[a-zA-Z0-9_-]{1,36}$/
         */
        submitId?: string;
        /** ISO currency code. Consult business documentation and agreeement to determine in which currencies transfers are provided to you. */
        currency: NewTransferInternalCurrencyEnum;
        /**
         * Transfer amount, example "999.00"
         * @pattern /^[0-9]{1,12}([.][0-9]{2})?$/
         */
        volume: string;
        /**
         * Transfer title, example "payment to invoice number 1/2018"
         * @maxLength 112
         */
        title?: string;
        /** Destination account number assigned to customer that receives transfer, example "WX1234567890WX" */
        accountNumber: string;
        /**
         * Destination account owner, example "Adventure Works Ltd"
         * @maxLength 90
         */
        recipientName: string;
        /**
         * Destination account owner address.
         * Address should have following format:<br/>
         * `<country code (required)>;<province>;<town (required)>;<postcode>;<street>;<building number>;<flat number>`<br/>
         * Which will be validated using regexp:<br/>
         * `/^[A-Z]{2};[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]+;[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]*$/`
         * <br/>Example: `PL;Pomorskie;Pruszcz Gdański;83-000;Ogrodowa;1;8`
         * @maxLength 90
         */
        recipientAddress?: string;
        /**
         * - `RECEIVER_VOLUME` means recipient will receive exact amount provided in volume attribute.
         * - `SENDER_VOLUME` means that volume attribute specifies sent volume (for certain transfers there are no guarantee that volume received is equal to volume sent, because extra charges may be deducted from transferred volume).
         *
         * Notes:
         *   - `transferCostInstruction` may have impact on transfer fee.
         *   - Business documentation specifies fees.
         */
        transferCostInstruction: NewTransferInternalTransferCostInstructionEnum;
      },
      params: RequestParams = {},
    ) =>
      this.request<NewTransferResponse, any>({
        path: `/transfer/internal`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.FormData,
        format: "json",
        ...params,
      }),

    /**
     * @description Requests transfer from wallet where destination account number is provided in IBAN format - either actual or just simulation to learn transfer possibility and cost in dry run mode.
     *
     * @tags payout
     * @name NewTransferIban
     * @summary Requests new transfer from wallet where destination account number is provided in IBAN format
     * @request POST:/transfer/iban
     * @secure
     */
    newTransferIban: (
      data: {
        /**
         * When true, dry run mode is on. In this mode transfer is not sent to execution, only request correctness, cost and possiblity to execute given transfer is checked instead
         * @default false
         */
        dryRun?: boolean;
        /**
         * Any unique transfer identifier assigned by sender, required when not in dry run mode, must not be used when dryRun=true, example "93a68f4d-ce40-40be-adac-3bb4d4b5e392"
         * @pattern /^[a-zA-Z0-9_-]{1,36}$/
         */
        submitId?: string;
        /**
         * Payout amount, example "999.00"
         * @pattern /^[0-9]{1,12}([.][0-9]{2})?$/
         */
        volume: string;
        /** ISO currency code. Consult business documentation and agreeement to determine in which currencies transfers are provided to you. */
        currency: NewTransferIbanCurrencyEnum;
        /**
         * Transfer title, example "payment to invoice number 1/2018". In certain cases title may be shortened by cutting end of title.
         * @maxLength 112
         */
        title?: string;
        /** Destination account number in IBAN format. Country code at the beginning of IBAN number is mandatory, example "PL71967221037685356996377436" */
        accountNumber: string;
        /**
         * Destination account owner, example "Adventure Works Ltd"
         * @maxLength 90
         */
        recipientName: string;
        /**
         * Destination account owner address. Address should have following format:<br/>
         * `<country code (required)>;<province>;<town (required)>;<postcode>;<street>;<building number>;<flat number>`<br/>
         * Which will be validated using regexp:<br/>
         * `/^[A-Z]{2};[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]+;[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]*$/`
         * <br/>Example: `PL;Pomorskie;Pruszcz Gdański;83-000;Ogrodowa;1;8`<br/>
         * For certain transfers address is required - check business documentation.
         *
         * Notes:
         *   - An address is required for transfers outside the EEA (GB, CH, and MC) or currency is not in the EEA currencies list.
         *   - An address is required for amounts above EUR 15,000 (and equivalent in another currency).
         * @maxLength 90
         */
        recipientAddress?: string;
        /**
         * Enables usually more expensive, but faster transfer. Availability may vary across currencies and destinations. Consult business documentation and agreement to determine availability, conditions and associated cost.
         * @default false
         */
        faster?: boolean;
        /**
         * - `RECEIVER_VOLUME` means recipient will receive exact amount provided in volume attribute.
         * - `SENDER_VOLUME` means that volume attribute specifies sent volume (for certain transfers there are no guarantee that volume received is equal to volume sent, because extra charges may be deducted from transferred volume).
         *
         * Notes:
         *   - `transferCostInstruction` may have impact on transfer fee.
         *   - It is possible that for certain countries and currencies we are not able to send transfer with RECEIVER_VOLUME option. In such case, requests with `RECEIVER_VOLUME` option will be rejected.
         *   - Business documentation specifies fees and possible transfer instructions for various transfer destinations.
         */
        transferCostInstruction: NewTransferIbanTransferCostInstructionEnum;
        /**
         * Extra information about requested transfer, reserved for certain API clients and cases. Please fill in only when requested and in the form you will receive in separate document. Endpoint will return error if filled in when not required or incorrectly filled.
         * @maxLength 106
         * @pattern /^([A-Za-z0-9 _.\-]+),([A-Za-zÀ-ž0-9 _.\-]+);(A|I):([A-Za-z0-9 _.\-]+)$/
         */
        additionalRemittanceInformation?: string;
        /** The purpose of transfer. Might be required for high volume and offshore transfers, detailed usage conditions outlined in the business agreement. */
        transferPurpose?: NewTransferIbanTransferPurposeEnum;
        /** Source of funds. Might be required for high volume and offshore transfers, detailed usage conditions outlined in the business agreement. */
        sourceOfIncome?: NewTransferIbanSourceOfIncomeEnum;
      },
      params: RequestParams = {},
    ) =>
      this.request<NewTransferResponse, any>({
        path: `/transfer/iban`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.FormData,
        format: "json",
        ...params,
      }),

    /**
     * @description Requests transfer from wallet where destination account number is provided in IBAN format - either actual or just simulation to learn transfer possibility and cost in dry run mode. This method is restricted to SEPA / SEPA INSTANT transfers only.
     *
     * @tags payout
     * @name NewTransferIbanSepa
     * @summary Requests new SEPA transfer from wallet where destination account number is provided in IBAN format.
     * @request POST:/transfer/iban/sepa
     * @secure
     */
    newTransferIbanSepa: (
      data: {
        /**
         * When true, dry run mode is on. In this mode transfer is not sent to execution, only request correctness, cost and possiblity to execute given transfer is checked instead
         * @default false
         */
        dryRun?: boolean;
        /**
         * Any unique transfer identifier assigned by sender, required when not in dry run mode, must not be used when dryRun=true, example "93a68f4d-ce40-40be-adac-3bb4d4b5e392"
         * @pattern /^[a-zA-Z0-9_-]{1,36}$/
         */
        submitId?: string;
        /**
         * Payout amount, example "999.00"
         * @pattern /^[0-9]{1,12}([.][0-9]{2})?$/
         */
        volume: string;
        /**
         * In certain cases title may be shortened by cutting end of title.
         * @maxLength 112
         * @pattern /^[A-Za-zÀ-ž0-9 _.,()\/\-]+$/
         */
        title?: string;
        /** Destination account number in IBAN format. Country code at the beginning of IBAN number is mandatory, example "PL71967221037685356996377436" */
        accountNumber: string;
        /**
         * Destination account owner, example "Adventure Works Ltd"
         * @maxLength 90
         * @pattern /^[A-Za-zÀ-ž0-9 _.\-]+$/
         */
        recipientName: string;
        /**
         * Destination account owner address. Address should have following format:<br/>
         * `<country code (required)>;<province>;<town (required)>;<postcode>;<street>;<building number>;<flat number>`<br/>
         * Which will be validated using regexp:<br/>
         * `/^[A-Z]{2};[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]+;[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]*;[A-Za-zÀ-ž0-9 _\.\-]*$/`
         * <br/>Example: `PL;Pomorskie;Pruszcz Gdański;83-000;Ogrodowa;1;8`
         * <br/>For certain transfers address is required - check business documentation.
         *
         * Notes:
         *   - An address is required for amounts above EUR 15,000 (and equivalent in another currency).
         * @maxLength 90
         */
        recipientAddress?: string;
        /**
         * Differentiates between SEPA [false] and SEPA INSTANT [true] transfer types. Consult business documentation and agreement to determine availability, conditions and associated cost.
         * @default false
         */
        instant?: boolean;
        /**
         * Extra information about requested transfer, reserved for certain API clients and cases. Please fill in only when requested and in the form you will receive in separate document. Endpoint will return error if filled in when not required or incorrectly filled.
         * @maxLength 106
         * @pattern /^([A-Za-z0-9 _.\-]+),([A-Za-zÀ-ž0-9 _.\-]+);(A|I):([A-Za-z0-9 _.\-]+)$/
         */
        additionalRemittanceInformation?: string;
        /** The purpose of transfer. Might be required for high volume and offshore transfers, detailed usage conditions outlined in the business agreement. */
        transferPurpose?: NewTransferIbanSepaTransferPurposeEnum;
        /** Source of funds. Might be required for high volume and offshore transfers, detailed usage conditions outlined in the business agreement. */
        sourceOfIncome?: NewTransferIbanSepaSourceOfIncomeEnum;
      },
      params: RequestParams = {},
    ) =>
      this.request<NewTransferResponse, any>({
        path: `/transfer/iban/sepa`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.FormData,
        format: "json",
        ...params,
      }),

    /**
     * @description Requests transfer from wallet where destination account number is provided in local non-IBAN format - either actual or just simulation to learn transfer possibility and cost in dry run mode. Endpoint availability and the list of available countries/destinations and transfer currencies depends on business agreement.
     *
     * @tags payout
     * @name NewTransferNoniban
     * @summary Requests new transfer from wallet to non-IBAN destinations
     * @request POST:/transfer/noniban
     * @secure
     */
    newTransferNoniban: (
      data: {
        /**
         * When true, dry run mode is on. In this mode transfer is not sent to execution, only request correctness, cost and possiblity to execute given transfer is checked instead
         * @default false
         */
        dryRun?: boolean;
        /**
         * Any unique transfer identifier assigned by sender, required when not in dry run mode, must not be used when dryRun=true, example "93a68f4d-ce40-40be-adac-3bb4d4b5e392"
         * @pattern /^[a-zA-Z0-9_-]{1,36}$/
         */
        submitId?: string;
        /**
         * Payout amount, example "999.00"
         * @pattern /^[0-9]{1,12}([.][0-9]{2})?$/
         */
        volume: string;
        /** ISO currency code. Consult business documentation and agreeement to determine in which currencies transfers are provided to you. */
        currency: NewTransferNonibanCurrencyEnum;
        /**
         * Transfer title, example "payment to invoice number 1/2018". Note that maximum allowed length is reduced in case additionalRemittanceInformation attribute is used. In certain cases title may be shortened by cutting end of title.
         * @maxLength 112
         */
        title?: string;
        /** Two letter code of supported destination country. Note: check list of destination countries enabled on your account. */
        country: NewTransferNonibanCountryEnum;
        /**
         * SWIFT code of beneficiary bank or financial institution
         * @maxLength 11
         * @pattern /^[A-Z]{6}[A-Z0-9]{2}([A-Z0-9]{3})?$/
         */
        swift: string;
        /** Destination account number. */
        accountNumber: string;
        /**
         * Destination account owner, example "Adventure Works Ltd"
         * @maxLength 90
         */
        recipientName: string;
        /**
         * Destination account owner address, example "14 Tottenham Court Road, London, England, W1T 1JY".
         *
         * Note: money transfers to China requires province code in the recipient address field compliant with ISO 3166-2, for example `CN-HK` for Hong Kong.
         * @maxLength 90
         */
        recipientAddress: string;
        /**
         * Enables usually more expensive, but faster transfer. Availability may vary across currencies and destinations. Consult business documentation and agreement to determine availability, conditions and associated cost.
         * @default false
         */
        faster?: boolean;
        /**
         * - `RECEIVER_VOLUME` means recipient will receive exact amount provided in volume attribute.
         * - `SENDER_VOLUME` means that volume attribute specifies sent volume (for certain transfers there are no guarantee that volume received is equal to volume sent, because extra charges may be deducted from transferred volume).
         *
         * Notes:
         *   - `transferCostInstruction` may have impact on transfer fee.
         *   - It is possible that for certain countries and currencies we are not able to send transfer with RECEIVER_VOLUME option. In such case, requests with `RECEIVER_VOLUME` option will be rejected.
         *   - Business documentation specifies fees and possible transfer instructions for various transfer destinations.
         */
        transferCostInstruction: NewTransferNonibanTransferCostInstructionEnum;
        /** The purpose of transfer */
        transferPurpose: NewTransferNonibanTransferPurposeEnum;
        /** Source of funds. */
        sourceOfIncome: NewTransferNonibanSourceOfIncomeEnum;
        /**
         * Extra information about requested transfer, reserved for certain API clients and cases. Please fill in only when requested and in the form you will receive in separate document. Endpoint will return error if filled in when not required or incorrectly filled.
         * @maxLength 106
         * @pattern /^([A-Za-z0-9 _.\-]+),([A-Za-zÀ-ž0-9 _.\-]+);(A|I):([A-Za-z0-9 _.\-]+)$/
         */
        additionalRemittanceInformation?: string;
      },
      params: RequestParams = {},
    ) =>
      this.request<NewTransferResponse, any>({
        path: `/transfer/noniban`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.FormData,
        format: "json",
        ...params,
      }),
  };
}
